## 1) 402 UX + 플랜/가격표

### 1-1) 402 응답을 “UX 친화”로 통일

`/api/jobs/confirm`에서 크레딧 부족 시 이미 402를 주고 있는데, payload를 이렇게 고정해두면 프론트가 편해요.

```ts
return NextResponse.json({
  error: "Not enough credits",
  code: "CREDITS_INSUFFICIENT",
  needed,
  balance,
  suggestions: [
    { pack: "Starter", credits: 10 },
    { pack: "Value", credits: 50 }
  ]
}, { status: 402 });
```

### 1-2) `/pricing` 페이지(테스트 결제 버튼 포함)

`app/pricing/page.tsx`

```tsx
"use client";
import { postJSON } from "@/lib/client/api";

const USER_ID = "demo-user";

const PACKS = [
  { name: "Starter", credits: 10, desc: "Story 4~5회 정도" },
  { name: "Value", credits: 50, desc: "Trailer/재생성까지 넉넉" },
  { name: "Pro", credits: 120, desc: "바이럴 실험/AB 테스트용" },
];

export default function PricingPage() {
  async function buy(credits: number) {
    await postJSON("/api/credits/purchase", { userId: USER_ID, amount: credits });
    alert(`크레딧 +${credits} (테스트 충전)`);
  }

  return (
    <div style={{ maxWidth: 720, margin: "40px auto", padding: 16 }}>
      <h1 style={{ fontSize: 24, fontWeight: 800 }}>크레딧 플랜</h1>
      <p style={{ opacity: 0.85 }}>
        Story = 2 크레딧 / Trailer = 5 크레딧 / Rewrite = +1 / 재생성(클립·장면) = 1
      </p>

      <div style={{ display: "grid", gap: 12, marginTop: 16 }}>
        {PACKS.map(p => (
          <div key={p.name} style={{ border: "1px solid #ddd", borderRadius: 14, padding: 14 }}>
            <div style={{ fontWeight: 800 }}>{p.name}</div>
            <div style={{ marginTop: 6 }}>{p.credits} credits</div>
            <div style={{ marginTop: 6, opacity: 0.8, fontSize: 13 }}>{p.desc}</div>
            <button onClick={() => buy(p.credits)} style={{ marginTop: 10, padding: "10px 12px", borderRadius: 10 }}>
              테스트로 충전
            </button>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 1-3) 402 발생 시 Select 화면에서 pricing으로 보내기

`/app/select/page.tsx` confirm() catch에서:

```ts
} catch (e: any) {
  const msg = e.message ?? String(e);
  setErr(msg);
  // 에러 문자열로만 받기 싫으면 postJSON을 개선해서 status/data를 같이 던지게 만들면 더 좋음
}
```

> 더 깔끔하게 하려면 `postJSON`을 “status 포함 에러”로 바꾸고, `status===402`면 `/pricing` 링크 버튼을 보여주면 돼요.

---

## 2) 재생성 UX + retryJob 추적/복제 + worker 부분생성

### 2-1) Job에 “부모 Job”과 “재생성 메타” 저장(추적 필수)

`prisma/schema.prisma`에 Job 필드 추가:

```prisma
model Job {
  // ...
  parentJobId String?
  parentJob   Job?      @relation("JobParent", fields: [parentJobId], references: [id])
  children    Job[]     @relation("JobParent")

  regenTarget String?
  regenClipNo Int?
  templateId  String?
  template    Template? @relation(fields: [templateId], references: [id])
}
```

마이그레이션.

### 2-2) Confirm 단계에서 templateId를 미리 고정(AB/재생성 안정화)

`/api/jobs/confirm`에서 queued로 바꾸기 전에 템플릿을 선택해서 `templateId` 저장.

**템플릿 variant 고정 규칙(조합당 3개 중 하나)**

* 같은 사용자/디바이스는 같은 variant를 받게(AB 측정 편해짐)

`lib/templates/chooser.ts`:

```ts
import crypto from "crypto";

export function chooseIndex(seed: string, n: number) {
  const h = crypto.createHash("sha256").update(seed).digest("hex");
  const v = parseInt(h.slice(0, 8), 16);
  return v % n;
}
```

`/api/jobs/confirm`에 적용:

```ts
import { chooseIndex } from "@/lib/templates/chooser";

const templates = await prisma.template.findMany({
  where: { mode, stage, genre },
  select: { id: true }
});
if (!templates.length) return NextResponse.json({ error: "No templates found" }, { status: 400 });

const seed = `${userId}|${deviceId ?? ""}|${stage}|${genre}|${mode}`;
const idx = chooseIndex(seed, templates.length);
const templateId = templates[idx].id;

// job update 시 templateId 저장
const job = await prisma.job.update({
  where: { id: draftJobId },
  data: { mode, stage, genre, slidersJson, rewriteEnabled, status: "queued", templateId }
});
```

> 이제 worker는 “랜덤 선택” 안 하고 job.templateId로 고정 템플릿을 씁니다. (재생성/AB 모두 안정화)

### 2-3) 재생성 API가 “사진/Rewrite/템플릿”을 복제 + parentJobId 연결

`/api/jobs/[jobId]/regenerate/route.ts`에서 retryJob 생성 후 아래를 추가:

* baseJob의 `photos` 복제
* baseJob의 `rewriteInput` 복제(있으면)
* templateId도 그대로 복제
* retryJob에 `parentJobId`, `regenTarget`, `regenClipNo` 저장

```ts
const base = await prisma.job.findUnique({
  where: { id: params.jobId },
  include: { photos: true, rewriteInput: true }
});
if (!base) return NextResponse.json({ error: "Not found" }, { status: 404 });

const retryJob = await prisma.job.create({
  data: {
    userId,
    mode: base.mode as any,
    stage: base.stage,
    genre: base.genre,
    slidersJson: base.slidersJson,
    rewriteEnabled: base.rewriteEnabled,
    status: "queued",
    templateId: base.templateId,
    parentJobId: base.id,
    regenTarget: target,
    regenClipNo: clipNo ?? null
  }
});

// photos 복제
for (const p of base.photos) {
  await prisma.jobPhoto.create({ data: { jobId: retryJob.id, url: p.url } });
}

// rewrite 복제
if (base.rewriteInput) {
  await prisma.rewriteInput.create({
    data: {
      jobId: retryJob.id,
      rawText: base.rewriteInput.rawText,
      sanitizedText: base.rewriteInput.sanitizedText,
      distanceMode: base.rewriteInput.distanceMode,
      desiredEnding: base.rewriteInput.desiredEnding
    }
  });
}
```

큐 payload는 그대로 `jobId: retryJob.id`만 넣어도 됨(메타는 DB에 있음).

### 2-4) worker: 부분 생성(clip 하나만 / 엔딩만)

`lib/generation/promptBuilder.ts`에 “필터 옵션” 추가:

```ts
export function buildPromptBundle(params: {
  job: any;
  templateBody: any;
  rewrite?: any;
  identityRefs?: string[];
  onlyKeys?: string[]; // 추가
}): PromptBundle {
  // ...
  const only = new Set(params.onlyKeys ?? []);
  // tasks push 할 때:
  // if onlyKeys가 있으면 해당 key만 생성
}
```

예: clip 2만 재생성하려면 `onlyKeys=["kf_2","clip_2"]`

worker에서:

```ts
const job = await prisma.job.findUnique({
  where: { id: jobId },
  include: { rewriteInput: true, photos: true, template: true }
});
const template = job.templateId
  ? await prisma.template.findUnique({ where: { id: job.templateId }, select: { bodyJson: true } })
  : null;
if (!template) throw new Error("template missing");

let onlyKeys: string[] | undefined;
if (job.parentJobId && job.regenTarget) {
  if (job.regenTarget === "story_clip" && job.regenClipNo) {
    onlyKeys = [`kf_${job.regenClipNo}`, `clip_${job.regenClipNo}`];
  }
  if (job.regenTarget === "rewrite_only") {
    onlyKeys = ["kf_3", "clip_3"];
  }
}

const bundle = buildPromptBundle({
  job,
  templateBody: body,
  rewrite: job.rewriteInput,
  identityRefs,
  onlyKeys
});
```

### 2-5) 결과 UI: “재생성” 버튼 추가

`/app/result/[jobId]/page.tsx`에서 quick이 아닌 경우 버튼 노출:

* Story: Clip 1/2/3 재생성
* Rewrite enabled면 “엔딩만 다시 만들기”

```tsx
async function regenStoryClip(clipNo: number) {
  const res = await postJSON<{ retryJobId: string }>(`/api/jobs/${jobId}/regenerate`, {
    userId: USER_ID,
    target: "story_clip",
    clipNo
  });
  router.push(`/result/${res.retryJobId}`);
}

async function regenEndingOnly() {
  const res = await postJSON<{ retryJobId: string }>(`/api/jobs/${jobId}/regenerate`, {
    userId: USER_ID,
    target: "rewrite_only",
    clipNo: 3
  });
  router.push(`/result/${res.retryJobId}`);
}
```

UI 버튼 예시:

```tsx
{data.mode !== "quick" && ready && (
  <div style={{ marginTop: 18, padding: 12, border: "1px solid #ddd", borderRadius: 12 }}>
    <div style={{ fontWeight: 800 }}>재생성</div>
    {data.mode === "story" && (
      <div style={{ display: "flex", gap: 8, flexWrap: "wrap", marginTop: 10 }}>
        {[1,2,3].map(n => (
          <button key={n} onClick={() => regenStoryClip(n)} style={{ padding:"8px 10px", borderRadius:10 }}>
            Clip {n} 다시
          </button>
        ))}
        {data.rewrite?.enabled && (
          <button onClick={regenEndingOnly} style={{ padding:"8px 10px", borderRadius:10 }}>
            엔딩만 다시
          </button>
        )}
      </div>
    )}
  </div>
)}
```

---

## 3) 이벤트 로깅 + 템플릿 A/B 분석 포인트

### 3-1) Prisma Event 테이블 추가

```prisma
model Event {
  id        String   @id @default(cuid())
  userId    String?
  jobId     String?
  name      String
  propsJson Json?
  createdAt DateTime @default(now())

  @@index([name, createdAt])
  @@index([jobId])
}
```

### 3-2) 이벤트 기록 헬퍼

`lib/analytics/log.ts`

```ts
import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();

export async function logEvent(name: string, props: any, ctx?: { userId?: string; jobId?: string }) {
  return prisma.event.create({
    data: { name, propsJson: props, userId: ctx?.userId, jobId: ctx?.jobId }
  });
}
```

### 3-3) “반드시 찍어야 하는 이벤트” 최소 세트

* `job_confirmed` (mode/stage/genre/rewriteEnabled/templateId)
* `job_done` (mode/templateId/latencySec)
* `upgrade_clicked` (fromMode → toMode)
* `share_created` / `share_viewed`
* `regen_requested` (target/clipNo)
* `credit_insufficient` (needed/balance)
* `credit_purchase_test` (amount)

예시: `/api/jobs/confirm`에

```ts
import { logEvent } from "@/lib/analytics/log";
// 성공 직후
await logEvent("job_confirmed", { mode, stage, genre, rewriteEnabled, templateId }, { userId, jobId: job.id });
```

worker 완료 시:

```ts
await logEvent("job_done", { mode: job.mode, templateId: job.templateId }, { userId: job.userId, jobId: job.id });
```

공유 생성 시:

```ts
await logEvent("share_created", { token }, { jobId });
```

### 3-4) A/B 분석을 위한 핵심: templateId(variant)별 전환 비교

이제 templateId가 job에 고정되니까,

* templateId별 `upgrade_clicked` / `share_created` / `regen_requested` 비율을 보면
  **어떤 템플릿(훅/엔딩)이 바이럴/만족도에 좋은지** 바로 나와요.

---


